---
import type { MarkdownHeading } from "astro";
import Icon from "$components/Icon.svelte";
import i18nit from "$i18n";

interface Props {
	locale: string;
	headings: Heading[];
}

const { locale, headings } = Astro.props;

const t = i18nit(locale);

// Extended heading type with additional properties for tree rendering
// - last: indicates if this heading is the last child in its parent group
// - lines: array of booleans indicating which vertical connector lines should be drawn
type Heading = MarkdownHeading & { last?: boolean; lines?: boolean[] };

// Determine which headings are the last in their sibling group
const stack: Heading[] = [];
headings.forEach(heading => {
	// Pop headings from the stack that are at the same or deeper level
	while (stack[stack.length - 1]?.depth >= heading.depth) {
		const top = stack.pop();
		// Mark as last if popped due to a shallower heading (not a sibling)
		if (top && top.depth !== heading.depth) top.last = true;
	}

	stack.push(heading);
});

// Mark all remaining headings in the stack as last (they have no following siblings)
while (stack.length > 0) stack.pop()!.last = true;

// Calculate which vertical connector lines to show for each heading
const actives: boolean[] = [];

headings.forEach(heading => {
	// For each depth level above this heading, record whether a vertical line should be drawn
	for (let depth = 2; depth < heading.depth; depth++) {
		heading.lines ??= [];
		heading.lines[depth - 2] = actives[depth - 2];
	}

	// Update the active state for this heading's depth level
	actives[heading.depth - 2] = !heading.last;
});
---

<style>
	#toc {
		transform: translateX(100%);

		&:is([dir="rtl"] *) {
			transform: translateX(-100%);
		}

		&.active {
			transform: translateX(0);
		}
	}

	#toc-overlay {
		pointer-events: none;
		background-color: transparent;

		&.active {
			pointer-events: auto;
			background-color: #aaaaaa88;
		}
	}
</style>

<div id="toc-overlay" aria-hidden="true" class="sm:hidden fixed top-0 inset-s-0 w-screen h-screen transition-[background-color] max-sm:z-110"></div>

<aside id="toc" class="sm:contents fixed top-0 inset-e-0 flex flex-col justify-between items-start gap-5 p-5 bg-background h-full overflow-hidden transition-transform max-sm:z-120">
	<div class="sm:sticky self-start top-3 w-50 flex flex-col gap-1 max-sm:h-full">
		<h4>{t("contents")}</h4>
		<nav class="overflow-y-auto">
			<!-- Original -->
			<ul class="flex flex-col text-base list-none">
				{
					headings.map((heading: Heading) => (
						<li id={`indicator-${heading.slug}`} class="group relative flex items-stretch h-6 [&.indicate>a]:font-bold [&.indicate>a]:text-primary">
							<div class="flex select-none" aria-hidden="true">
								{heading.lines?.map(line => (
									<div class="w-4 relative flex justify-center">{line && <span class="absolute top-0 bottom-0 border-s border-remark" />}</div>
								))}

								{heading.depth > 1 && (
									<div class="w-4 relative flex justify-center">
										<span class:list={["absolute top-0 border-s border-remark", heading.last ? "h-[calc(50%+1px)]" : "h-full"]} />
										<span class="absolute top-1/2 inset-s-1/2 w-2 border-b border-remark" />
									</div>
								)}
							</div>

							<a href={`#${heading.slug}`} title={heading.text} class="grow min-w-0 inline-flex items-center ps-1 text-weak hover:font-bold hover:text-primary transition-[color,font-weight]">
								<span class="truncate">{heading.text}</span>
							</a>
						</li>
					))
				}
			</ul>
		</nav>
		<button id="toc-close" class="sm:hidden mt-auto ms-auto mb-2 me-2"><Icon name="lucide--x" /></button>
	</div>
</aside>

<script>
	// Global variable to store the IntersectionObserver instance
	// Used to clean up previous observer when re-initializing
	let observer: IntersectionObserver | undefined;

	// Sidebar open/close logic
	let sidebar: HTMLElement;
	let overlay: HTMLElement;
	let close: HTMLElement;

	function handleOpen() {
		sidebar?.classList.add("active");
		overlay?.classList.add("active");
	}

	function handleClose() {
		sidebar?.classList.remove("active");
		overlay?.classList.remove("active");
	}

	/**
	 * Initialize Table of Contents functionality with scroll-based highlighting
	 * Sets up intersection observer to highlight current section in TOC
	 */
	function TOC() {
		// Create a Map for efficient lookup of TOC indicators by heading slug
		// Maps heading slug to corresponding TOC list item element
		const indicators = new Map<string, Element>(
			document
				.querySelectorAll("li[id^='indicator-']") // Select all TOC indicator elements
				.values()
				.map(indicator => [
					indicator.id.replace(/^indicator-/, ""), // Extract slug from "indicator-{slug}" format
					indicator // Store the indicator element
				])
		);

		// Disconnect previous observer to prevent memory leaks
		observer?.disconnect();

		// Create new IntersectionObserver to detect when headings enter/leave viewport
		observer = new IntersectionObserver(entries =>
			entries.forEach(({ target, isIntersecting }) => {
				// Get heading slug from `aria-labelledby` attribute
				const slug = target.getAttribute("aria-labelledby");
				if (!slug) return;

				// Toggle "indicate" class on corresponding TOC item based on visibility
				indicators.get(slug)?.classList.toggle("indicate", isIntersecting);
			})
		);

		// Find all heading sections in the markdown content and observe them
		document
			.querySelector("#markdown-content") // Get main content container
			?.querySelectorAll("section[data-heading-rank]") // Find all heading sections
			.forEach(section => observer?.observe(section)); // Start observing each section

		sidebar = document.getElementById("toc")!;
		overlay = document.getElementById("toc-overlay")!;
		close = document.getElementById("toc-close")!;

		close?.addEventListener("click", handleClose);
		overlay?.addEventListener("click", handleClose);
		document.querySelectorAll("#toc nav ul li a").forEach(link => link.addEventListener("click", handleClose));
	}

	// Initialize TOC functionality when page loads
	TOC();

	// Re-initialize TOC after Astro's view transitions complete
	// This ensures TOC works correctly with client-side navigation
	document.addEventListener("astro:after-swap", TOC);

	// Listen for open event dispatched by the Position component button
	document.addEventListener("toc:open", handleOpen);
</script>
